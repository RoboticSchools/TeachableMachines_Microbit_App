<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Teachable Machines + AI Vision Micro:bit (rbs - optimized)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
:root{
  --bg:#0f1115;
  --card:#14161a;
  --accent:#00c3ff;
  --good:#00ff99;
  --warn:#ffcc66;
  --error:#ff6b6b;
  --muted:#9fdfff;
  --panel-radius:14px;
  --gap:18px;
  --pad:18px;
  --left-width:300px;
  --right-width:360px;
  --max-width:1400px;
}
html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:Inter,Segoe UI,Arial,sans-serif;display:flex;align-items:flex-start;justify-content:center;padding:28px;}
.page { width:100%; max-width:var(--max-width); display:flex; flex-direction:column; gap:18px; align-items:center; }
.top-header { position: fixed; top: 28px; left: 28px; z-index:100; display:flex; align-items:center; gap:10px; }
.logo { height:44px; width:auto; cursor:pointer; transition:transform .18s ease; }
.logo:hover{ transform:scale(1.04); }
h1{font-weight:600;margin:6px 0 0 0;text-align:center}
.top-controls{ width:100%; display:flex; flex-direction:column; gap:12px; align-items:center; }
.controls-row{ width:100%; display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap; }
.model-row{ display:flex; gap:10px; align-items:center; justify-content:center; }
.model-row input[type="text"]{ width:420px; max-width:760px; padding:12px 14px; border-radius:12px; border:0; background:#0b0c0e; color:#fff; box-shadow:inset 0 1px 0 rgba(255,255,255,0.02); font-size:15px; }
.model-row button{ padding:10px 18px; border-radius:10px; border:0; background:var(--accent); color:#002; font-weight:700; cursor:pointer; box-shadow:0 6px 18px rgba(0,195,255,0.06); }

.mid-buttons{ display:flex; gap:14px; align-items:center; justify-content:center; margin-top:0; }
.mid-buttons button{ padding:12px 22px; border-radius:12px; border:0; background:#1b1e25; color:#fff; cursor:pointer; font-weight:600; box-shadow:0 6px 18px rgba(0,0,0,0.4); }

.status-bar{ width:100%; max-width:980px; display:flex; justify-content:center; margin-top:6px; }
.status{ width:100%; max-width:820px; background:var(--card); padding:10px 14px; border-radius:12px; text-align:center; color:var(--muted); font-weight:600; box-shadow:0 6px 20px rgba(0,0,0,0.45); }

.content{ width:100%; display:grid; grid-template-columns: var(--left-width) 1fr var(--right-width); gap:24px; align-items:start; margin-top:6px; }
.classes-panel{ background:var(--card); border-radius:14px; padding:14px; box-shadow:0 12px 30px rgba(0,0,0,0.5); max-height:640px; display:flex; flex-direction:column; gap:12px; overflow:hidden; }
.classes-panel h3{ margin:0; font-size:15px; font-weight:800; color:var(--muted); display:flex; justify-content:space-between; align-items:center; }
.classes-list{ display:flex; flex-direction:column; gap:8px; overflow:auto; padding-right:6px; margin-top:6px; }
.class-row{ display:flex; justify-content:space-between; align-items:center; padding:10px 12px; border-radius:10px; background:rgba(255,255,255,0.015); font-weight:600; }
.class-name{ overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:180px; }
.class-pct{ min-width:48px; text-align:right; color:var(--muted); font-weight:700; }

.video-card{ background:linear-gradient(180deg,#0b0c0e,#0f1115); padding:14px; border-radius:18px; box-shadow:0 12px 40px rgba(0,0,0,0.6); display:flex; flex-direction:column; align-items:center; gap:12px; min-height:460px; justify-content:center; }
video#video{ width:100%; max-width:720px; height:420px; border-radius:14px; background:#000; object-fit:cover; display:block; box-shadow:0 6px 18px rgba(0,0,0,0.6); transform:scaleX(-1); }

.right-col{ display:flex; flex-direction:column; gap:14px; align-items:stretch; }
.card{ background:var(--card); border-radius:12px; padding:12px; box-shadow:0 8px 30px rgba(0,0,0,0.45); }
.slider-row{ display:flex; align-items:center; gap:10px; }
input[type="range"]{ width:100%; accent-color:var(--accent); margin:0; }
.percent{ min-width:46px; text-align:right; font-weight:700; color:var(--muted); }

#mainLabel{ font-size:20px; font-weight:800; text-align:center; padding:18px 12px; border-radius:10px; background:rgba(255,255,255,0.02); color:#fff; min-height:56px; display:flex; align-items:center; justify-content:center; }
.deviceName{ font-size:13px; color:#bfefff; margin-top:6px; text-align:center; }

#webcam-container { width:100%; display:flex; align-items:center; justify-content:center; }
@media (max-width:1100px){
  .content{ grid-template-columns: 260px 1fr 360px; gap:18px; }
  video#video{ height:360px; }
}
@media (max-width:860px){
  .content{ grid-template-columns: 1fr; }
  .classes-panel{ order: -1; width:100%; }
  .video-card{ width:100%; }
  .right-col{ width:100%; }
  video#video{ height:320px; max-width:100%; }
}
  </style>

  <!-- tfjs + teachablemachine helper -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>
</head>
<body>
  <header class="top-header">
    <img src="logo.png" alt="Robotic Schools Logo" class="logo">
  </header>

  <div class="page">
    <h1>Teachable Machines + AI Vision Micro:bit</h1>

    <div class="top-controls">
      <div class="controls-row">
        <div class="model-row">
          <input id="modelUrl" type="text" placeholder="Paste the Model URL or ID ..." />
          <button id="loadBtn">Load Model</button>
        </div>

        <div class="mid-buttons">
          <button id="connectBtn">connect micro:bit</button>
        </div>
      </div>

      <div class="status-bar">
        <div id="status" class="status">status label</div>
      </div>

    </div>

    <div class="content">
      <div class="classes-panel">
        <h3>Classes <span id="classCount" style="font-weight:700;color:var(--muted)">—</span></h3>
        <div class="classes-list" id="classes"></div>
      </div>

      <div class="video-card">
        <div id="webcam-container">
          <video id="video" autoplay playsinline muted style="display:none"></video>
        </div>
      </div>

      <div class="right-col">
        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div style="font-weight:700">Threshold</div>
          </div>
          <div style="height:10px"></div>
          <div class="slider-row">
            <input id="thresh" type="range" min="30" max="95" value="65" />
            <div class="percent" id="threshPct">65%</div>
          </div>
        </div>

        <div class="card" id="mainCard">
          <div id="mainLabel">—</div>
        </div>

        <div class="card" style="padding:10px;">
          <div style="font-weight:700;margin-bottom:8px">Device</div>
          <div class="deviceName" id="deviceName">—</div>
        </div>
      </div>
    </div>
  </div>

<script>
/* ---------------- UI elements ---------------- */
const loadBtn = document.getElementById('loadBtn');
const connectBtn = document.getElementById('connectBtn');
const statusEl = document.getElementById('status');
const modelUrlInput = document.getElementById('modelUrl');
const mainLabelEl = document.getElementById('mainLabel');
const threshRange = document.getElementById('thresh');
const threshPct = document.getElementById('threshPct');
const classesEl = document.getElementById('classes');
const classCountEl = document.getElementById('classCount');
const deviceNameEl = document.getElementById('deviceName');
const webcamContainer = document.getElementById('webcam-container');

threshRange.addEventListener('input', ()=>{ threshPct.textContent = threshRange.value + '%'; });
loadBtn.addEventListener('click', loadModel);
connectBtn.addEventListener('click', connectMicrobit);

function setStatus(txt, color = '#9fdfff'){
  statusEl.textContent = txt;
  statusEl.style.color = color;
}

/* ---------------- BLE (kept from rbs) ---------------- */
const UART_SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
const UART_NOTIFY_CHAR_UUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';
const UART_WRITE_CHAR_UUID  = '6e400003-b5a3-f393-e0a9-e50e24dcca9e';

let bleDevice = null;
let bleServer = null;
let uartService = null;
let notifyChar = null;
let writeChar = null;
const encoder = new TextEncoder();
let writeQueue = Promise.resolve();
let connected = false;
let reconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 8;

function queueGattOperation(op){ writeQueue = writeQueue.then(op, op); return writeQueue; }
function safeLog(...args){ console.log('[BLE]', ...args); }

async function connectMicrobit(){
  try {
    setStatus('Requesting micro:bit...', '#00c3ff');
    bleDevice = await navigator.bluetooth.requestDevice({
      filters: [{ namePrefix: 'BBC micro:bit' }],
      optionalServices: [UART_SERVICE_UUID]
    });
    if(!bleDevice) throw new Error('No device selected');
    bleDevice.addEventListener('gattserverdisconnected', handleDisconnected);
    deviceNameEl.textContent = `Device: ${bleDevice.name || 'micro:bit'}`;

    setStatus('Connecting...', '#00c3ff');
    bleServer = await bleDevice.gatt.connect();

    setStatus('Getting UART service...', '#00c3ff');
    uartService = await bleServer.getPrimaryService(UART_SERVICE_UUID);

    setStatus('Getting characteristics...', '#00c3ff');
    writeChar = await uartService.getCharacteristic(UART_WRITE_CHAR_UUID).catch(()=>null);
    notifyChar = await uartService.getCharacteristic(UART_NOTIFY_CHAR_UUID).catch(()=>null);
    if(notifyChar && (notifyChar.properties.notify || notifyChar.properties.indicate)){
      await notifyChar.startNotifications();
      notifyChar.addEventListener('characteristicvaluechanged', onNotify);
    }

    connected = true;
    reconnectAttempts = 0;
    setStatus(`Connected: ${bleDevice.name || 'micro:bit'}`, '#00ff99');
    connectBtn.textContent = 'Connected';
    deviceNameEl.textContent = `Device: ${bleDevice.name || 'micro:bit'}`;
  } catch (err) {
    console.error('Connect failed', err);
    setStatus('Bluetooth connection failed (try again)', '#ff6b6b');
    deviceNameEl.textContent = '';
    bleDevice = null;
    connected = false;
    connectBtn.textContent = 'connect micro:bit';
  }
}
function handleDisconnected(event){
  const dev = event.target;
  safeLog(`Device ${dev.name} disconnected`);
  connected = false;
  setStatus('Disconnected — attempting reconnect...', 'orange');
  attemptReconnect();
}
function attemptReconnect(){
  if(!bleDevice){ setStatus('Not connected', '#ffcc66'); connectBtn.textContent = 'connect micro:bit'; return; }
  reconnectAttempts++;
  if(reconnectAttempts > MAX_RECONNECT_ATTEMPTS){
    setStatus('Reconnect failed — click Connect', '#ff6b6b');
    connectBtn.textContent = 'connect micro:bit';
    deviceNameEl.textContent = '';
    return;
  }
  const backoffMs = Math.min(1000 * Math.pow(2, reconnectAttempts-1), 20000);
  safeLog('Reconnect attempt', reconnectAttempts, 'next in ms', backoffMs);
  setTimeout(async () => {
    try {
      setStatus(`Reconnect attempt ${reconnectAttempts}...`, '#00c3ff');
      bleServer = await bleDevice.gatt.connect();
      uartService = await bleServer.getPrimaryService(UART_SERVICE_UUID);
      writeChar = await uartService.getCharacteristic(UART_WRITE_CHAR_UUID).catch(()=>null);
      notifyChar = await uartService.getCharacteristic(UART_NOTIFY_CHAR_UUID).catch(()=>null);
      if(notifyChar && (notifyChar.properties.notify || notifyChar.properties.indicate)){
        await notifyChar.startNotifications();
        notifyChar.addEventListener('characteristicvaluechanged', onNotify);
      }
      connected = true;
      reconnectAttempts = 0;
      setStatus(`Reconnected: ${bleDevice.name || 'micro:bit'}`, '#00ff99');
      connectBtn.textContent = 'Connected';
      deviceNameEl.textContent = `Device: ${bleDevice.name || 'micro:bit'}`;
    } catch(e){
      console.warn('Reconnect attempt failed', e);
      attemptReconnect();
    }
  }, backoffMs);
}
function onNotify(ev){
  const value = ev.target.value;
  const text = new TextDecoder().decode(value);
  safeLog('Notified:', text);
}
function sendUARTRaw(bytes){
  if(!writeChar){
    safeLog('No write characteristic - cannot send');
    setStatus('Not writable - reconnect or check micro:bit firmware', '#ff6b6b');
    return Promise.reject(new Error('No write characteristic'));
  }
  return queueGattOperation(async () => {
    try {
      if(typeof writeChar.writeValue === 'function'){
        await writeChar.writeValue(bytes);
      } else if(typeof writeChar.writeValueWithoutResponse === 'function'){
        await writeChar.writeValueWithoutResponse(bytes);
      } else {
        if(writeChar.properties && writeChar.properties.writeWithoutResponse && typeof writeChar.writeValue === 'function'){
          await writeChar.writeValue(bytes);
        } else {
          throw new Error('No writable method on characteristic');
        }
      }
      safeLog('Sent bytes', bytes);
    } catch (err){
      console.error('Write failed', err);
      throw err;
    }
  });
}
async function sendToMicrobit(text){
  if(!connected || !writeChar){
    safeLog('Skipped send - not connected or writable');
    return;
  }
  try {
    const payload = encoder.encode(String(text) + '\n');
    await sendUARTRaw(payload);
  } catch(e){
    console.error('sendToMicrobit error', e);
  }
}

/* ---------------- Performance & decision tuning ---------------- */
// prefer WebGL backend for faster inference
(async () => {
  try {
    if (tf && tf.setBackend) {
      await tf.setBackend('webgl');
      await tf.ready();
      console.log('tf backend set to', tf.getBackend());
      setStatus('Using tf backend: ' + tf.getBackend(), '#9fdfff');
    }
  } catch (e) {
    console.warn('Could not set webgl backend, using default.', e);
  }
})();

// decision constants tuned for low latency
const STABLE_FRAMES_REQUIRED = 2; // accept after 2 consistent frames
const COOLDOWN_MS = 700;          // UI cooldown after acceptance

// BLE send throttling
const BLE_SEND_COOLDOWN_MS = 300;
let lastSentLabel = null;
let lastSentAt = 0;

/* ---------------- Teachable Machine integration (tmImage) ---------------- */
const tm = window.tmImage; // teachablemachine helper

let tmModel = null;
let webcam = null;
let maxPredictions = 0;
let labels = [];
let running = false;

// smoothing & buffer
let smoothingBuffer = [];
let smoothingFrames = 2; // small smoothing window for low latency

let candidateIdx = null;
let stableCount = 0;
let lastAcceptedIdx = null;
let lastAcceptedAt = 0;

function renderClassesPlaceholder(){
  classesEl.innerHTML = '';
  labels.forEach((l,i)=>{
    const row = document.createElement('div');
    row.className = 'class-row';
    row.innerHTML = `<div class="class-name">${l}</div><div class="class-pct" id="p-${i}">—</div>`;
    classesEl.appendChild(row);
  });
  classCountEl.textContent = labels.length ? labels.length + ' total' : '—';
}
function renderProbabilities(arr){
  arr.forEach((p,i)=>{
    const el = document.getElementById('p-'+i);
    if(el) el.textContent = (p*100).toFixed(0) + '%';
  });
}

/* Normalize base helper (reuse from rbs) */
function normalizeBase(urlOrId){
  if(!urlOrId) return null;
  const s = urlOrId.trim();
  if(!s) return null;
  if(s.startsWith('http')){
    try{
      const u = new URL(s);
      const parts = u.pathname.split('/').filter(Boolean);
      const idx = parts.indexOf('models');
      if(idx>=0 && parts.length>idx+1) return `https://teachablemachine.withgoogle.com/models/${parts[idx+1]}/`;
    }catch(e){}
    if(s.endsWith('model.json')) return s.replace(/model\.json$/,'');
    return s.endsWith('/') ? s : s + '/';
  } else {
    return `https://teachablemachine.withgoogle.com/models/${s}/`;
  }
}

/* load model (tmImage.load) */
async function loadModel(){
  const base = normalizeBase(modelUrlInput.value);
  if(!base){ setStatus('Provide model URL or id', '#ffcc66'); return; }
  setStatus('Loading model...', '#00c3ff');
  try {
    const modelURL = base + 'model.json';
    const metadataURL = base + 'metadata.json';

    // load using teachablemachine helper to ensure correct preprocessing
    tmModel = await tm.load(modelURL, metadataURL);
    maxPredictions = tmModel.getTotalClasses();

    // attempt to get labels
    try {
      if(typeof tmModel.getClassLabels === 'function'){
        labels = tmModel.getClassLabels();
      } else if(Array.isArray(tmModel.labels)){
        labels = tmModel.labels;
      } else if(tmModel?.metadata?.labels){
        labels = tmModel.metadata.labels;
      } else if(Array.isArray(tmModel?.model?.labels)){
        labels = tmModel.model.labels;
      }
    } catch(e){ console.warn('label read error', e); }

    if(!labels || labels.length===0){
      labels = new Array(maxPredictions).fill(0).map((_,i)=>`Class ${i}`);
    }

    setStatus('Model loaded — ' + labels.length + ' classes', '#00ff99');
    renderClassesPlaceholder();

    // warm up model AFTER backend set (reduces first inference jank)
    try {
      const inShape = tmModel?.model?.inputs?.[0]?.shape;
      const h = (inShape && inShape.length>=4) ? inShape[1] : 224;
      const w = (inShape && inShape.length>=4) ? inShape[2] : 224;
      const warm = tf.zeros([1,h,w,3]);
      const warmOut = tmModel.model.predict(warm);
      if(Array.isArray(warmOut)){
        warmOut.forEach(t=>t.dispose && t.dispose());
      } else {
        warmOut.dispose && warmOut.dispose();
      }
      warm.dispose();
    } catch(e){
      console.warn('Warmup failed', e);
    }

    // init (or re-init) webcam with smaller resolution for speed
    if(!webcam){
      try { await initWebcam(); } catch(e){}
    }

    if(webcam && tmModel && !running){
      predictLoop();
    }
  } catch(err){
    console.error(err);
    setStatus('Model load failed — check URL/CORS', '#ff6b6b');
    tmModel = null;
  }
}

/* init webcam using tm.Webcam with smaller input (224x224) */
async function initWebcam(){
  try {
    if(webcam && typeof webcam.stop === 'function'){ webcam.stop(); webcam = null; }

    // use 224x224 input for faster inference (matches many TM defaults)
    const INPUT_SIZE = 224;
    // flip = true mirrors input so gestures/labels map to user view
    webcam = new tm.Webcam(INPUT_SIZE, INPUT_SIZE, true);

    await webcam.setup(); // asks camera permission if needed
    await webcam.play();

    // attach and visually scale canvas to keep UI large while processing smaller image
    webcamContainer.innerHTML = "";
    webcamContainer.appendChild(webcam.canvas);
    webcam.canvas.style.maxWidth = '480px';
    webcam.canvas.style.width = '480px';
    webcam.canvas.style.height = 'auto';
    webcam.canvas.style.borderRadius = '12px';

    setStatus('Camera started', '#9fdfff');
    return;
  } catch(e){
    console.error('Webcam init error', e);
    setStatus(e.name === 'NotAllowedError' ? 'Camera permission denied' : 'Camera error: ' + (e.message || e.name), '#ff6b6b');
    throw e;
  }
}

/* Main predict loop (tmModel.predict on webcam.canvas) */
async function predictLoop(){
  if(!tmModel){ setStatus('Load model first', '#ffcc66'); return; }
  if(!webcam){ setStatus('Start camera first', '#ffcc66'); return; }
  running = true;
  setStatus('Predicting...', '#9fdfff');

  smoothingBuffer = [];

  async function step(){
    if(!running) return;
    try {
      webcam.update();
      const predictions = await tmModel.predict(webcam.canvas);

      const probs = predictions.map(p=>p.probability);

      // smoothing buffer
      smoothingBuffer.push(probs);
      if(smoothingBuffer.length > smoothingFrames) smoothingBuffer.shift();

      // compute avg
      const avg = new Array(probs.length).fill(0);
      smoothingBuffer.forEach(arr=>{
        for(let i=0;i<arr.length;i++) avg[i]+=arr[i];
      });
      for(let i=0;i<avg.length;i++) avg[i] = avg[i] / smoothingBuffer.length;

      // UI
      renderProbabilities(avg);

      // decision logic
      const confThreshold = Math.max(0, Math.min(1, (parseInt(threshRange.value)||65)/100));
      let bestIdx = 0; let bestProb = avg[0]||0;
      for(let i=1;i<avg.length;i++){ if(avg[i]>bestProb){ bestProb=avg[i]; bestIdx=i; } }

      const now = Date.now();
      if(lastAcceptedAt && (now - lastAcceptedAt) < COOLDOWN_MS){
        if(lastAcceptedIdx !== null){
          mainLabelEl.textContent = `${labels[lastAcceptedIdx] || ('Class '+lastAcceptedIdx)}`;
        }
      } else {
        if(bestProb >= confThreshold){
          if(candidateIdx === bestIdx) stableCount++;
          else { candidateIdx = bestIdx; stableCount = 1; }
          if(stableCount >= STABLE_FRAMES_REQUIRED){
            if(lastAcceptedIdx !== candidateIdx){
              lastAcceptedIdx = candidateIdx;
              lastAcceptedAt = Date.now();
              mainLabelEl.textContent = `${labels[lastAcceptedIdx] || ('Class '+lastAcceptedIdx)}`;

              // BLE send with throttle: only send when label changed or cooldown passed
              const labelToSend = labels[lastAcceptedIdx];
              const nowSend = Date.now();
              if(labelToSend && (labelToSend !== lastSentLabel || (nowSend - lastSentAt) > BLE_SEND_COOLDOWN_MS)){
                lastSentLabel = labelToSend;
                lastSentAt = nowSend;
                // fire-and-forget (do not await to avoid blocking)
                sendToMicrobit(labelToSend).catch(e=>console.warn('BLE send failed', e));
              }
            }
          }
        } else {
          candidateIdx = null;
          stableCount = 0;
        }
      }

    } catch(err){
      console.error('Prediction loop error', err);
      setStatus('Prediction error — see console', '#ff6b6b');
      running = false;
      return;
    }
    requestAnimationFrame(step);
  }
  step();
}

/* cleanup on unload */
window.addEventListener('beforeunload', ()=>{
  try { if(webcam && typeof webcam.stop === 'function') webcam.stop(); } catch(e){}
  try { if(notifyChar && notifyChar.stopNotifications) notifyChar.stopNotifications(); } catch(e){}
  try { if(bleDevice && bleDevice.gatt && bleDevice.gatt.connected) bleDevice.gatt.disconnect(); } catch(e){}
});

/* Attempt to auto-start camera (best-effort). Model still needs to be loaded via Load Model button */
(async function autoStart(){
  try { await initWebcam(); } catch(e){}
})();

</script>
</body>
</html>
