<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Teachable Machines + AI Vision — Micro:bit + Arduino (rbs)</title>

  <!-- TFJS + Teachable Machine helper -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>

  <style>
    :root{
      --bg:#0d0f12;
      --card:rgba(255,255,255,0.03);
      --muted:#9fdfff;
      --accent-color:#00c3ff;
      --accent-2:#00ffa3;
      --radius:14px;
      --gap:16px;
      --max-width:1180px;
      --slider-height:10px;
      --thumb-size:22px;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:#eafcff;font-family:Inter,Segoe UI,Arial,sans-serif}
    .top-header{position:fixed;top:18px;left:18px;z-index:200;display:flex;align-items:center;gap:12px}
    .logo{height:52px;width:auto;cursor:pointer}
    .container{max-width:var(--max-width);margin:84px auto;padding:18px;display:grid;grid-template-columns:260px 1fr 360px;gap:var(--gap);align-items:start}
    header.page-header{grid-column:1/-1;display:flex;flex-direction:column;align-items:center;gap:20px;margin-bottom:0;padding-top:6px}
    h1{margin:0;font-size:20px;font-weight:800;text-align:center}
    .controls{width:100%;display:flex;flex-direction:column;gap:14px;align-items:center}
    .model-row{display:flex;gap:12px;align-items:center}
    input[type="text"]{width:520px;max-width:100%;padding:12px 14px;border-radius:12px;border:0;background:#0b0c0e;color:#fff;font-size:14px;box-shadow:inset 0 1px 0 rgba(255,255,255,0.02)}
    .btn{padding:10px 14px;border-radius:12px;border:0;font-weight:700;cursor:pointer;color:#002b30; background:linear-gradient(90deg,var(--accent-color),var(--accent-2)); box-shadow:0 8px 24px rgba(0,195,255,0.08); display:inline-flex;align-items:center;justify-content:center}
    .controls-row-second{display:flex;gap:18px;align-items:center;justify-content:center;width:100%;margin-top:6px;flex-wrap:wrap}
    .status{background:var(--card);padding:8px 12px;border-radius:12px;color:var(--muted);font-weight:700;min-width:240px;text-align:center}
    .classes-panel{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.015));border-radius:12px;padding:12px;box-shadow:0 6px 20px rgba(0,0,0,0.6);max-height:640px;display:flex;flex-direction:column;gap:10px;overflow:hidden}
    .classes-list{display:flex;flex-direction:column;gap:8px;overflow:auto;padding-right:6px;margin-top:6px}
    .class-row{display:flex;justify-content:space-between;align-items:center;padding:8px 10px;border-radius:10px;background:rgba(255,255,255,0.012);font-weight:600}
    .video-card{background:#000;border-radius:var(--radius);overflow:hidden;min-height:240px;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:8px;box-shadow:0 12px 40px rgba(0,0,0,0.6)}
    .webcam-canvas{border-radius:12px;max-width:720px;width:100%;height:auto;display:block;box-shadow:0 6px 18px rgba(0,0,0,0.6);background:#000;object-fit:cover;transform:scaleX(-1);}
    .webcam-canvas.smaller { max-height:320px; height:320px; width:auto; }
    .right-col{display:flex;flex-direction:column;gap:12px;align-items:stretch}
    .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.015));padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.02);box-shadow:0 8px 30px rgba(0,0,0,0.45)}
    /* slider */
    .slider-card{padding:18px;display:flex;flex-direction:column;gap:12px;align-items:stretch}
    .slider-wrap{position:relative;width:100%;padding-top:18px}
    input[type="range"]{
      -webkit-appearance:none;
      appearance:none;
      width:100%;
      height:var(--slider-height);
      border-radius:999px;
      background:linear-gradient(90deg,var(--accent-color),var(--accent-2));
      outline:none;
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.04);
    }
    input[type="range"]::-webkit-slider-runnable-track{height:var(--slider-height);border-radius:999px}
    input[type="range"]::-moz-range-track{height:var(--slider-height);border-radius:999px}
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width:var(--thumb-size);
      height:var(--thumb-size);
      border-radius:50%;
      background:linear-gradient(180deg,#fff,#dffaff);
      border:3px solid rgba(0,195,255,0.18);
      box-shadow:0 6px 18px rgba(0,0,0,0.5);
      margin-top: calc((var(--thumb-size) / -2) + (var(--slider-height)/2));
    }
    input[type="range"]::-moz-range-thumb{
      width:var(--thumb-size);
      height:var(--thumb-size);
      border-radius:50%;
      background:linear-gradient(180deg,#fff,#dffaff);
      border:3px solid rgba(0,195,255,0.18);
      box-shadow:0 6px 18px rgba(0,0,0,0.5);
    }
    .bubble{
      position:absolute;
      top:0;
      transform:translateX(-50%);
      background:linear-gradient(180deg,#002b30,#00404a);
      color:#bff9ff;
      padding:6px 8px;border-radius:8px;font-weight:800;font-size:12px;
      box-shadow:0 6px 18px rgba(0,0,0,0.5);
      pointer-events:none;
      white-space:nowrap;
    }
    .bubble::after{
      content:'';
      position:absolute;
      left:50%;
      transform:translateX(-50%);
      bottom:-6px;
      width:10px;height:10px;background:linear-gradient(180deg,#002b30,#00404a);
      transform:translateX(-50%) rotate(45deg);
      border-radius:2px;
    }
    .slider-meta{display:flex;justify-content:space-between;align-items:center;font-weight:700;color:var(--muted);font-size:13px}
    #mainLabel{font-size:18px;font-weight:800;text-align:center;padding:12px;border-radius:10px;background:rgba(255,255,255,0.02);color:#fff;min-height:52px;display:flex;align-items:center;justify-content:center}
    @media(max-width:1100px){
      .container{grid-template-columns:220px 1fr 320px;padding:14px}
      .webcam-canvas.smaller{height:280px;max-height:280px}
    }
    @media(max-width:860px){
      .container{grid-template-columns:1fr;gap:12px;margin-top:84px}
      .classes-panel{order:-1;width:100%}
      .video-card{width:100%}
      .right-col{width:100%}
      input[type="text"]{width:100%}
      .controls-row-second{justify-content:space-between;padding:0 12px;gap:10px}
    }
  </style>
</head>
<body>
  <header class="top-header" aria-hidden="true">
    <img src="logo.png" alt="Robotic Schools Logo" class="logo">
  </header>

  <div class="container" role="main">
    <header class="page-header" aria-label="App header">
      <h1>Teachable Machines + AI Vision — Micro:bit + Arduino</h1>

      <div class="controls">
        <div class="model-row">
          <input id="modelUrl" type="text" placeholder="Paste the Model URL or ID ..." />
          <button id="loadBtn" class="btn">Load Model</button>
        </div>

        <div class="controls-row-second" aria-live="polite">
          <button id="connectMicrobitBtn" class="btn">Connect micro:bit</button>
          <div id="connStatus" class="status">Not connected</div>
          <button id="connectArduinoBtn" class="btn">Connect Arduino</button>
        </div>
      </div>
    </header>

    <aside class="classes-panel" aria-label="Classes panel">
      <h3>Classes <span id="classCount" style="font-weight:700;color:#9fdfff">—</span></h3>
      <div class="classes-list" id="classes"></div>
    </aside>

    <main class="video-card" aria-label="Camera preview">
      <div id="webcam-container" style="width:100%;display:flex;align-items:center;justify-content:center;">
        <video id="video" autoplay playsinline muted style="display:none"></video>
      </div>
    </main>

    <section class="right-col" aria-label="Controls & info">
      <div class="card slider-card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:800">Threshold</div>
        </div>

        <div class="slider-wrap">
          <input id="thresh" type="range" min="30" max="95" value="65" />
          <div class="bubble" id="threshBubble">65%</div>
        </div>

        <div class="slider-meta">
          <div style="opacity:0.9"></div>
          <div id="threshPct" style="font-weight:900;color:var(--muted)">65%</div>
        </div>
      </div>

      <div class="card" id="mainCard">
        <div id="mainLabel">—</div>
      </div>
    </section>
  </div>

  <script>
    /* ---------- UI refs ---------- */
    const loadBtn = document.getElementById('loadBtn');
    const connectBtn = document.getElementById('connectMicrobitBtn');
    const connectArduinoBtn = document.getElementById('connectArduinoBtn');
    const statusEl = document.getElementById('connStatus');
    const modelUrlInput = document.getElementById('modelUrl');
    const mainLabelEl = document.getElementById('mainLabel');
    const threshRange = document.getElementById('thresh');
    const threshPct = document.getElementById('threshPct');
    const threshBubble = document.getElementById('threshBubble');
    const classesEl = document.getElementById('classes');
    const classCountEl = document.getElementById('classCount');
    const webcamContainer = document.getElementById('webcam-container');

    /* style buttons gradient (keeps gradient even if classes differ) */
    function applyButtonGradient(btn){
      btn.style.background = 'linear-gradient(90deg,var(--accent-color),var(--accent-2))';
      btn.style.color = '#002b30';
      btn.style.boxShadow = '0 8px 24px rgba(0,195,255,0.08)';
    }
    [loadBtn, connectBtn, connectArduinoBtn].forEach(el => applyButtonGradient(el));

    /* update slider UI position (bubble) */
    function updateSliderUI(){
      const val = parseInt(threshRange.value);
      const min = parseInt(threshRange.min || 0);
      const max = parseInt(threshRange.max || 100);
      const pct = (val - min) / (max - min) * 100;
      threshBubble.style.left = pct + '%';
      threshBubble.textContent = val + '%';
      threshPct.textContent = val + '%';
    }
    threshRange.addEventListener('input', updateSliderUI);
    updateSliderUI();

    loadBtn.addEventListener('click', loadModel);
    connectBtn.addEventListener('click', connectMicrobit);
    connectArduinoBtn.addEventListener('click', connectArduino);

    function setStatus(txt, color = ''){ statusEl.textContent = txt; statusEl.style.color = color || ''; }

    /* ---------------- Web Serial (Arduino) ---------------- */
    let port = null, writer = null, reader = null, serialConnected = false;
    const textEncoder = new TextEncoder();
    let serialWriteQueue = Promise.resolve();
    function queueOp(op){ serialWriteQueue = serialWriteQueue.then(op, op); return serialWriteQueue; }

    async function ensurePortOpen(requestIfMissing = true){
      if (!('serial' in navigator)) throw new Error('Web Serial not supported');
      if (port) {
        if (port.readable === false && port.writable === false) {
          try { await port.open({ baudRate: 115200 }); } catch(e){}
        }
        return port;
      }
      if (!requestIfMissing) throw new Error('No port available');
      const requested = await navigator.serial.requestPort();
      await requested.open({ baudRate: 115200 });
      port = requested;
      return port;
    }

    async function connectArduino(){
      if (serialConnected) { await disconnectArduino(); return; }
      try {
        setStatus('Requesting Arduino port...', '#00c3ff');
        connectArduinoBtn.textContent = 'Requesting...';
        await ensurePortOpen(true);
        try { if (!port.readable || !port.writable) await port.open({ baudRate: 115200 }).catch(()=>{}); } catch(e){}
        if (port.writable) { try { writer = port.writable.getWriter(); } catch(e){ writer = null; } } else writer = null;
        if (port.readable) { try { reader = port.readable.getReader(); readLoop().catch(()=>{}); } catch(e){ reader = null; } }
        serialConnected = true;
        setStatus('Connected to Arduino', '#00ff99');
        connectArduinoBtn.textContent = 'Disconnect';
        updateButtonsVisibility();
      } catch (err) {
        serialConnected = false;
        setStatus('Arduino connection failed', '#ff6b6b');
        connectArduinoBtn.textContent = 'Connect Arduino';
        console.error('Serial connect error', err);
        updateButtonsVisibility();
      }
    }

    async function disconnectArduino(){
      connectArduinoBtn.textContent = 'Disconnecting...';
      setStatus('Disconnecting Arduino...');
      try {
        if (reader) { await reader.cancel().catch(()=>{}); try { reader.releaseLock(); } catch(e){} reader = null; }
      } catch(e){}
      try {
        if (writer) { try { await writer.close(); } catch(e){} try { writer.releaseLock(); } catch(e){} writer = null; }
      } catch(e){}
      try { if (port) { try { await port.close(); } catch(e){} port = null; } } catch(e){}
      serialConnected = false;
      setStatus(serialConnected ? 'Connected to Arduino' : 'Not connected');
      connectArduinoBtn.textContent = 'Connect Arduino';
      updateButtonsVisibility();
    }

    async function readLoop(){
      if (!port || !port.readable) return;
      try {
        while (true) {
          const r = await reader.read();
          if (!r) break;
          const { value, done } = r;
          if (done) break;
        }
      } catch (e) {
      } finally {
        try { if (reader) { reader.releaseLock(); } } catch(e){}
        reader = null;
        if (serialConnected) {
          serialConnected = false;
          setStatus('Arduino disconnected', '#ffcc66');
          connectArduinoBtn.textContent = 'Connect Arduino';
          updateButtonsVisibility();
        }
      }
    }

    function sendSerialLine(line){
      if (!port) return;
      return queueOp(async () => {
        try {
          if (!writer && port.writable) { try { writer = port.writable.getWriter(); } catch(e){ writer = null; } }
          if (!writer) throw new Error('No writer');
          await writer.write(textEncoder.encode(line + '\n'));
        } catch (e) {
          console.warn('Serial write error', e);
          try {
            if (writer) { try { writer.releaseLock(); } catch(e){} writer = null; }
            if (port && port.readable === false && port.writable === false) {
              try { await port.close(); } catch(e){ }
              port = null;
              serialConnected = false;
              setStatus('Arduino disconnected', '#ff6b6b');
              connectArduinoBtn.textContent = 'Connect Arduino';
              updateButtonsVisibility();
            }
          } catch(e){}
        }
      });
    }

    /* ---------------- Web Bluetooth (micro:bit) ---------------- */
    const UART_SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
    const UART_NOTIFY_CHAR_UUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';
    const UART_WRITE_CHAR_UUID  = '6e400003-b5a3-f393-e0a9-e50e24dcca9e';

    let bleDevice = null, bleServer = null, uartService = null, notifyChar = null, writeChar = null;
    let bleConnected = false;
    let bleWriteQueue = Promise.resolve();
    const MAX_RECONNECT_ATTEMPTS = 8;
    let reconnectAttempts = 0;
    function queueGattOperation(op){ bleWriteQueue = bleWriteQueue.then(op, op); return bleWriteQueue; }
    function safeLog(...args){ console.log('[BLE]', ...args); }

    async function connectMicrobit(){
      if (bleConnected) { await disconnectMicrobit(); return; }
      if (!('bluetooth' in navigator)) {
        alert('Web Bluetooth not supported. Use Chrome/Edge.');
        return;
      }
      try {
        setStatus('Requesting micro:bit...', '#00c3ff');
        connectBtn.textContent = 'Requesting...';
        bleDevice = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: 'BBC micro:bit' }],
          optionalServices: [UART_SERVICE_UUID]
        });
        if(!bleDevice) throw new Error('No device selected');
        bleDevice.addEventListener('gattserverdisconnected', handleDisconnected);
        setStatus('Connecting...', '#00c3ff');
        bleServer = await bleDevice.gatt.connect();
        setStatus('Getting UART service...', '#00c3ff');
        uartService = await bleServer.getPrimaryService(UART_SERVICE_UUID);
        setStatus('Getting characteristics...', '#00c3ff');
        writeChar = await uartService.getCharacteristic(UART_WRITE_CHAR_UUID).catch(()=>null);
        notifyChar = await uartService.getCharacteristic(UART_NOTIFY_CHAR_UUID).catch(()=>null);
        if(notifyChar && (notifyChar.properties.notify || notifyChar.properties.indicate)){
          await notifyChar.startNotifications();
          notifyChar.addEventListener('characteristicvaluechanged', onNotify);
        }
        bleConnected = true; reconnectAttempts = 0;
        setStatus(`Connected: ${bleDevice.name || 'micro:bit'}`, '#00ff99');
        connectBtn.textContent = 'Disconnect';
        updateButtonsVisibility();
      } catch (err) {
        console.error('BLE connect failed', err);
        setStatus('micro:bit: connection failed', '#ff6b6b');
        bleDevice = null; bleConnected = false;
        connectBtn.textContent = 'Connect micro:bit';
        updateButtonsVisibility();
      }
    }

    async function disconnectMicrobit(){
      connectBtn.textContent = 'Disconnecting...';
      try { if (notifyChar && notifyChar.stopNotifications) await notifyChar.stopNotifications(); } catch(e){}
      try { if (bleDevice && bleDevice.gatt && bleDevice.gatt.connected) bleDevice.gatt.disconnect(); } catch(e){}
      bleDevice = null; bleServer = null; writeChar = null; notifyChar = null; bleConnected = false;
      connectBtn.textContent = 'Connect micro:bit';
      setStatus(serialConnected ? 'Connected to Arduino' : 'Not connected');
      updateButtonsVisibility();
    }

    function handleDisconnected(event){
      const dev = event.target;
      safeLog(`Device ${dev && dev.name} disconnected`);
      bleConnected = false;
      setStatus('Disconnected — attempting reconnect...', '#ffcc66');
      attemptReconnect();
    }

    function attemptReconnect(){
      if(!bleDevice){
        setStatus('Not connected');
        connectBtn.textContent = 'Connect micro:bit';
        updateButtonsVisibility();
        return;
      }
      reconnectAttempts++;
      if(reconnectAttempts > MAX_RECONNECT_ATTEMPTS){
        setStatus('Reconnect failed — click Connect', '#ff6b6b');
        connectBtn.textContent = 'Connect micro:bit';
        bleDevice = null; bleConnected = false;
        updateButtonsVisibility();
        return;
      }
      const backoffMs = Math.min(1000 * Math.pow(2, reconnectAttempts-1), 20000);
      setTimeout(async () => {
        try {
          setStatus(`Reconnect attempt ${reconnectAttempts}...`, '#00c3ff');
          bleServer = await bleDevice.gatt.connect();
          uartService = await bleServer.getPrimaryService(UART_SERVICE_UUID);
          writeChar = await uartService.getCharacteristic(UART_WRITE_CHAR_UUID).catch(()=>null);
          notifyChar = await uartService.getCharacteristic(UART_NOTIFY_CHAR_UUID).catch(()=>null);
          if(notifyChar && (notifyChar.properties.notify || notifyChar.properties.indicate)){
            await notifyChar.startNotifications();
            notifyChar.addEventListener('characteristicvaluechanged', onNotify);
          }
          bleConnected = true; reconnectAttempts = 0;
          setStatus(`Reconnected: ${bleDevice.name || 'micro:bit'}`, '#00ff99');
          connectBtn.textContent = 'Disconnect';
          updateButtonsVisibility();
        } catch(e){
          console.warn('Reconnect attempt failed', e);
          attemptReconnect();
        }
      }, backoffMs);
    }

    function onNotify(ev){
      const value = ev.target.value;
      const text = new TextDecoder().decode(value);
      safeLog('Notified:', text);
    }

    function sendUARTRaw(bytes){
      if(!writeChar){
        safeLog('No write characteristic - cannot send');
        setStatus('Not writable - reconnect or check micro:bit firmware', '#ff6b6b');
        return Promise.reject(new Error('No write characteristic'));
      }
      return queueGattOperation(async () => {
        try {
          if(typeof writeChar.writeValue === 'function'){
            await writeChar.writeValue(bytes);
          } else if(typeof writeChar.writeValueWithoutResponse === 'function'){
            await writeChar.writeValueWithoutResponse(bytes);
          } else {
            if(writeChar.properties && writeChar.properties.writeWithoutResponse && typeof writeChar.writeValue === 'function'){
              await writeChar.writeValue(bytes);
            } else {
              throw new Error('No writable method on characteristic');
            }
          }
        } catch (err){
          console.error('Write failed', err);
          throw err;
        }
      });
    }

    async function sendToMicrobit(text){
      if(!bleConnected || !writeChar) return;
      try {
        const payload = textEncoder.encode(String(text) + '\n');
        await sendUARTRaw(payload);
      } catch(e){
        console.error('sendToMicrobit error', e);
      }
    }

    function updateButtonsVisibility(){
      if (serialConnected) {
        connectBtn.style.display = 'none';
        connectArduinoBtn.style.display = '';
        setStatus('Connected to Arduino', '#00ff99');
      } else if (bleConnected) {
        connectArduinoBtn.style.display = 'none';
        connectBtn.style.display = '';
        setStatus(`Connected: ${bleDevice.name || 'micro:bit'}`, '#00ff99');
      } else {
        connectMicrobitBtn.style.display = '';
        connectArduinoBtn.style.display = '';
        setStatus('Not connected');
      }
    }

    /* ---------- Teachable Machine integration (tmImage) ---------- */
    const tm = window.tmImage;
    let tmModel = null, webcam = null, labels = [], running = false;
    let smoothingBuffer = [], smoothingFrames = 2;
    const STABLE_FRAMES_REQUIRED = 2;
    const COOLDOWN_MS = 700;
    const BLE_SEND_COOLDOWN_MS = 300;
    let candidateIdx = null, stableCount = 0, lastAcceptedIdx = null, lastAcceptedAt = 0;
    let lastSentLabel = null, lastSentAt = 0;

    function renderClassesPlaceholder(){
      classesEl.innerHTML = '';
      labels.forEach((l,i)=>{
        const row = document.createElement('div');
        row.className = 'class-row';
        row.innerHTML = `<div class="class-name">${l}</div><div class="class-pct" id="p-${i}">—</div>`;
        classesEl.appendChild(row);
      });
      classCountEl.textContent = labels.length ? labels.length + ' total' : '—';
    }
    function renderProbabilities(arr){
      arr.forEach((p,i)=>{
        const el = document.getElementById('p-'+i);
        if(el) el.textContent = (p*100).toFixed(0) + '%';
      });
    }

    function normalizeBase(urlOrId){
      if(!urlOrId) return null;
      const s = urlOrId.trim();
      if(!s) return null;
      if(s.startsWith('http')){
        try{
          const u = new URL(s);
          const parts = u.pathname.split('/').filter(Boolean);
          const idx = parts.indexOf('models');
          if(idx>=0 && parts.length>idx+1) return `https://teachablemachine.withgoogle.com/models/${parts[idx+1]}/`;
        }catch(e){}
        if(s.endsWith('model.json')) return s.replace(/model\.json$/,'');
        return s.endsWith('/') ? s : s + '/';
      } else {
        return `https://teachablemachine.withgoogle.com/models/${s}/`;
      }
    }

    async function loadModel(){
      const base = normalizeBase(modelUrlInput.value);
      if(!base){ setStatus('Provide model URL or id', '#ffcc66'); return; }
      setStatus('Loading model...', '#00c3ff');
      try {
        const modelURL = base + 'model.json';
        const metadataURL = base + 'metadata.json';
        tmModel = await tm.load(modelURL, metadataURL);
        const maxPredictions = tmModel.getTotalClasses();

        try {
          if(typeof tmModel.getClassLabels === 'function'){
            labels = tmModel.getClassLabels();
          } else if(Array.isArray(tmModel.labels)){
            labels = tmModel.labels;
          } else if(tmModel?.metadata?.labels){
            labels = tmModel.metadata.labels;
          } else if(Array.isArray(tmModel?.model?.labels)){
            labels = tmModel.model.labels;
          }
        } catch(e){ console.warn('label read error', e); }

        if(!labels || labels.length===0){
          labels = new Array(maxPredictions).fill(0).map((_,i)=>`Class ${i}`);
        }

        setStatus('Model loaded — ' + labels.length + ' classes', '#00ff99');
        renderClassesPlaceholder();

        // warm up
        try {
          const inShape = tmModel?.model?.inputs?.[0]?.shape;
          const h = (inShape && inShape.length>=4) ? inShape[1] : 224;
          const w = (inShape && inShape.length>=4) ? inShape[2] : 224;
          const warm = tf.zeros([1,h,w,3]);
          const warmOut = tmModel.model.predict(warm);
          if(Array.isArray(warmOut)){
            warmOut.forEach(t=>t.dispose && t.dispose());
          } else {
            warmOut.dispose && warmOut.dispose();
          }
          warm.dispose();
        } catch(e){ console.warn('Warmup failed', e); }

        if(!webcam){
          try { await initWebcam(); } catch(e){}
        }
        if(webcam && tmModel && !running) predictLoop();
      } catch(err){
        console.error(err);
        setStatus('Model load failed — check URL/CORS', '#ff6b6b');
        tmModel = null;
      }
    }

    async function initWebcam(){
      try {
        if(webcam && typeof webcam.stop === 'function'){ webcam.stop(); webcam = null; }
        const INPUT_SIZE = 224;
        // mirror preview: tm.Webcam flip + CSS transform
        webcam = new tm.Webcam(INPUT_SIZE, INPUT_SIZE, true);
        await webcam.setup();
        await webcam.play();
        webcamContainer.innerHTML = "";
        webcamContainer.appendChild(webcam.canvas);
        webcam.canvas.className = 'webcam-canvas smaller';
        webcam.canvas.style.transform = 'scaleX(-1)'; // ensure mirror
        webcam.canvas.style.maxHeight = '320px';
        webcam.canvas.style.height = '320px';
        webcam.canvas.style.width = 'auto';
        setStatus('Camera started', '#9fdfff');
        return;
      } catch(e){
        console.error('Webcam init error', e);
        setStatus(e.name === 'NotAllowedError' ? 'Camera permission denied' : 'Camera error: ' + (e.message || e.name), '#ff6b6b');
        throw e;
      }
    }

    async function predictLoop(){
      if(!tmModel){ setStatus('Load model first', '#ffcc66'); return; }
      if(!webcam){ setStatus('Start camera first', '#ffcc66'); return; }
      running = true;
      setStatus('Predicting...', '#9fdfff');
      smoothingBuffer = [];
      async function step(){
        if(!running) return;
        try {
          webcam.update();
          const predictions = await tmModel.predict(webcam.canvas);
          const probs = predictions.map(p=>p.probability);
          smoothingBuffer.push(probs);
          if(smoothingBuffer.length > smoothingFrames) smoothingBuffer.shift();
          const avg = new Array(probs.length).fill(0);
          smoothingBuffer.forEach(arr=>{
            for(let i=0;i<arr.length;i++) avg[i]+=arr[i];
          });
          for(let i=0;i<avg.length;i++) avg[i] = avg[i] / smoothingBuffer.length;
          renderProbabilities(avg);
          const confThreshold = Math.max(0, Math.min(1, (parseInt(threshRange.value)||65)/100));
          let bestIdx = 0; let bestProb = avg[0]||0;
          for(let i=1;i<avg.length;i++){ if(avg[i]>bestProb){ bestProb=avg[i]; bestIdx=i; } }
          const now = Date.now();
          if(lastAcceptedAt && (now - lastAcceptedAt) < COOLDOWN_MS){
            if(lastAcceptedIdx !== null){
              mainLabelEl.textContent = `${labels[lastAcceptedIdx] || ('Class '+lastAcceptedIdx)}`;
            }
          } else {
            if(bestProb >= confThreshold){
              if(candidateIdx === bestIdx) stableCount++;
              else { candidateIdx = bestIdx; stableCount = 1; }
              if(stableCount >= STABLE_FRAMES_REQUIRED){
                if(lastAcceptedIdx !== candidateIdx){
                  lastAcceptedIdx = candidateIdx;
                  lastAcceptedAt = Date.now();
                  mainLabelEl.textContent = `${labels[lastAcceptedIdx] || ('Class '+lastAcceptedIdx)}`;

                  const labelToSend = labels[lastAcceptedIdx];
                  const nowSend = Date.now();
                  if(labelToSend && (labelToSend !== lastSentLabel || (nowSend - lastSentAt) > BLE_SEND_COOLDOWN_MS)){
                    lastSentLabel = labelToSend; lastSentAt = nowSend;
                    if (serialConnected) { sendSerialLine(labelToSend); }
                    else if (bleConnected) { sendToMicrobit(labelToSend).catch(e=>console.warn('BLE send failed', e)); }
                  }
                }
              }
            } else {
              candidateIdx = null; stableCount = 0;
            }
          }
        } catch(err){
          console.error('Prediction loop error', err);
          setStatus('Prediction error — see console', '#ff6b6b');
          running = false;
          return;
        }
        requestAnimationFrame(step);
      }
      step();
    }

    /* cleanup on unload */
    window.addEventListener('beforeunload', async ()=>{
      try { if(webcam && typeof webcam.stop === 'function') webcam.stop(); } catch(e){}
      try { if(reader) { await reader.cancel().catch(()=>{}); try { reader.releaseLock(); } catch(e){} reader = null; } } catch(e){}
      try { if(writer) { try { await writer.close(); } catch(e){} try { writer.releaseLock(); } catch(e){} writer = null; } } catch(e){}
      try { if(port) { try { await port.close(); } catch(e){} port = null; } } catch(e){}
      try { if(notifyChar && notifyChar.stopNotifications) await notifyChar.stopNotifications(); } catch(e){}
      try { if(bleDevice && bleDevice.gatt && bleDevice.gatt.connected) bleDevice.gatt.disconnect(); } catch(e){}
    });

    /* sync UI state */
    setInterval(() => {
      if (bleDevice && bleDevice.gatt) {
        const nowBle = !!bleDevice.gatt.connected;
        if (nowBle !== bleConnected) {
          bleConnected = nowBle;
          setStatus(bleConnected ? `Connected: ${bleDevice.name || 'micro:bit'}` : 'Not connected');
          connectBtn.textContent = bleConnected ? 'Disconnect' : 'Connect micro:bit';
          updateButtonsVisibility();
        }
      }
      if (port) {
        const writable = !!port.writable;
        const readable = !!port.readable;
        const nowSerial = writable || readable || serialConnected;
        if (!nowSerial && serialConnected) {
          serialConnected = false;
        }
      }
      if (serialConnected) {
        setStatus('Connected to Arduino', '#00ff99');
        connectArduinoBtn.textContent = 'Disconnect';
      } else {
        if (!bleConnected) {
          setStatus('Not connected');
        }
        connectArduinoBtn.textContent = 'Connect Arduino';
      }
      updateButtonsVisibility();
    }, 1200);
  </script>
</body>
</html>
